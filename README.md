# ps_study
ps공부, 모각소를 위한 레포지토리

## 목차
1. [1주차](#1주차---c언어-풀이)
2. [2주차](#2주차---c언어-풀이)

## 1주차 - c언어 풀이
2026-01-14 시행

### 2738번 배열 문제

* 해당 문제는 최대 100 * 100 크기의 2차원 행렬까지로 문제가 정의되어 있으므로 arr1과 arr2 배열을 100 * 100 크기의 2차원 행렬로 선언했습니다.    
만약 malloc을 통한 동적 할당으로 문제의 행렬을 정의할 경우 메모리가 커져 문제의 제한을 초과하게 됩니다.
* 그 후엔 이중 for문을 통해 배열 각각의 값을 입력받고, 다시 이중 for문을 통해 행렬 덧셈을 수행하여 문제를 풀이하였습니다.

### 2751번 정렬 문제

* 해당 문제는 N개의 수가 정렬되지 않은 상태로 주어지면 이를 오름차순으로 정렬하는 프로그램을 작성하는 문제였습니다. 
* 해당 문제를 단순히 bubble sort같은 알고리즘을 사용하여 프로그램을 만들면 시간 초과로 인해 틀리게 된다는 사실을 알았습니다. 시간 제한 2초를 만족하기 위해서는 merge sort 알고리즘으로 프로그램을 작성해야 했습니다.
* merge sort는 최선, 평균, 최악의 경우 모두에서 시간복잡도가 n log n인데 반해 다른 알고리즘들은 그렇지 않기에 해당 알고리즘으로 프로그램을 작성해야 했습니다.
* 해당 알고리즘은 devide and conquer 방식의 일종으로 코드에선 merge_sort 함수로 devide 하고 merge 함수로 conquer 해주었습니다.
* 구현은 일반적인 merge sort의 방식을 그대로 따라하여 알고리즘의 구현이 어떻게 되는지 학습하였습니다.

## 2주차 - C언어 풀이

### 10845번 queue 문제

* 해당 문제는 queue에 대한 구현을 바탕으로 정해진 입력 형식을 통해 원하는 출력이 나오게 해야했습니다.
* 사실 queue 구현은 쉬웠으나 입력을 어떻게 받는지에 대한 것을 구현할 때 c언어의 특성을 잘 모르다보니 그 부분이 힘들었습니다.
* push 명령어의 경우엔 어떤 수를 push할 것인지 까지 입력받아야 하는데 다른 명령어의 경우 그런 것이 없으므로 문자열의 갯수가 달라 어떻게 입력받아야 하는지에서 시간이 오래 걸렸습니다.
* scanf의 경우 공백을 기준으로 문자열을 구분한다는 것을 알게 됐습니다. 원래는 enter를 입력해야 문자열 등을 입력받을 수 있는 것으로 알고 있었으나 그것이 아니었습니다. 문자열을 쓰다가 띄어쓰기를 하면 그것이 입력되는 형식입니다.
* 그것을 알고 보니 예전에 개행문자에 대한 처리가 필요했던 문제들이 생각났습니다. scanf가 공백을 기준으로 문자를 입력받기 때문에 enter를 누르면 개행문자가 버퍼에 남아 해당 문자를 처리하지 않으면 다음 입력을 받을 때 이 개행문자가 입력으로 들어간다는 것을 떠올렸습니다.
* scanf의 특성을 깨닫고 
```
    scanf("%s", expression);

    if(!strcmp(expression, "push")){
        scanf("%d", &a);
        push(a);
    }
```
다음과 같이 구현해 문제 풀이를 완료했습니다.

### 11054번 가장 긴 바이토닉 부분 수열 문제 구상
* 해당 문제는 풀이를 하지 않았고 어떻게 풀어야 하는지 토론하였습니다.
* 수가 연결되지 않아도 하나하나 추출해서 순서대로 나열했을 때 가장 길게 바이토닉 부분 수열이 만들어진다면 해당 수열이 가장 긴 바이토닉 수열로 취급되는 것이 문제였습니다. 
* 그래서 구상한 아이디어는 어떤 수로부터 가장 길게 증가하는 수열을 배열에 저장하고 끝나는 지점에서 가장 길게 감소하는 수열을 배열에 저장해 그것이 가장 긴 것을 찾는다는 것이었습니다.
* 해당 문제의 구현은 다음 주차에 진행할 예정입니다.
