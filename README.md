# ps_study
ps공부, 모각소를 위한 레포지토리

## 목차
1. [1주차](#1주차---c언어-풀이)
2. [2주차](#2주차---c언어-풀이)
3. [3주차](#3주차---c언어-풀이)
4. [4주차](#4주차---c언어-풀이)
5. [5주차](#5주차---c언어-풀이)

## 1주차 - c언어 풀이
2026-01-14 시행

### 2738번 배열 문제

* 해당 문제는 최대 100 * 100 크기의 2차원 행렬까지로 문제가 정의되어 있으므로 arr1과 arr2 배열을 100 * 100 크기의 2차원 행렬로 선언했습니다.    
만약 malloc을 통한 동적 할당으로 문제의 행렬을 정의할 경우 메모리가 커져 문제의 제한을 초과하게 됩니다.
* 그 후엔 이중 for문을 통해 배열 각각의 값을 입력받고, 다시 이중 for문을 통해 행렬 덧셈을 수행하여 문제를 풀이하였습니다.

### 2751번 정렬 문제

* 해당 문제는 N개의 수가 정렬되지 않은 상태로 주어지면 이를 오름차순으로 정렬하는 프로그램을 작성하는 문제였습니다. 
* 해당 문제를 단순히 bubble sort같은 알고리즘을 사용하여 프로그램을 만들면 시간 초과로 인해 틀리게 된다는 사실을 알았습니다. 시간 제한 2초를 만족하기 위해서는 merge sort 알고리즘으로 프로그램을 작성해야 했습니다.
* merge sort는 최선, 평균, 최악의 경우 모두에서 시간복잡도가 n log n인데 반해 다른 알고리즘들은 그렇지 않기에 해당 알고리즘으로 프로그램을 작성해야 했습니다.
* 해당 알고리즘은 devide and conquer 방식의 일종으로 코드에선 merge_sort 함수로 devide 하고 merge 함수로 conquer 해주었습니다.
* 구현은 일반적인 merge sort의 방식을 그대로 따라하여 알고리즘의 구현이 어떻게 되는지 학습하였습니다.

## 2주차 - C언어 풀이
2026-01-21 시행

### 10845번 queue 문제

* 해당 문제는 queue에 대한 구현을 바탕으로 정해진 입력 형식을 통해 원하는 출력이 나오게 해야했습니다.
* 사실 queue 구현은 쉬웠으나 입력을 어떻게 받는지에 대한 것을 구현할 때 c언어의 특성을 잘 모르다보니 그 부분이 힘들었습니다.
* push 명령어의 경우엔 어떤 수를 push할 것인지 까지 입력받아야 하는데 다른 명령어의 경우 그런 것이 없으므로 문자열의 갯수가 달라 어떻게 입력받아야 하는지에서 시간이 오래 걸렸습니다.
* scanf의 경우 공백을 기준으로 문자열을 구분한다는 것을 알게 됐습니다. 원래는 enter를 입력해야 문자열 등을 입력받을 수 있는 것으로 알고 있었으나 그것이 아니었습니다. 문자열을 쓰다가 띄어쓰기를 하면 그것이 입력되는 형식입니다.
* 그것을 알고 보니 예전에 개행문자에 대한 처리가 필요했던 문제들이 생각났습니다. scanf가 공백을 기준으로 문자를 입력받기 때문에 enter를 누르면 개행문자가 버퍼에 남아 해당 문자를 처리하지 않으면 다음 입력을 받을 때 이 개행문자가 입력으로 들어간다는 것을 떠올렸습니다.
* scanf의 특성을 깨닫고 
```
    scanf("%s", expression);

    if(!strcmp(expression, "push")){
        scanf("%d", &a);
        push(a);
    }
```
다음과 같이 구현해 문제 풀이를 완료했습니다.

### 11054번 가장 긴 바이토닉 부분 수열 문제 구상
* 해당 문제는 풀이를 하지 않았고 어떻게 풀어야 하는지 토론하였습니다.
* 수가 연결되지 않아도 하나하나 추출해서 순서대로 나열했을 때 가장 길게 바이토닉 부분 수열이 만들어진다면 해당 수열이 가장 긴 바이토닉 수열로 취급되는 것이 문제였습니다. 
* 그래서 구상한 아이디어는 어떤 수로부터 가장 길게 증가하는 수열을 배열에 저장하고 끝나는 지점에서 가장 길게 감소하는 수열을 배열에 저장해 그것이 가장 긴 것을 찾는다는 것이었습니다.
* 해당 문제의 구현은 다음 주차에 진행할 예정입니다.

## 3주차 - C언어 풀이
2026-01-30 시행

### 1647번 graph 문제 (18352번 문제는 어떤 문제인지 참고만 함)

* 해당 문제는 N개의 집, 즉 N개의 정점 node와 M개의 길의 수, 즉 M개의 간선 edge 사이에서 최단 거리를 구하는 문제였습니다.
* kruskal 알고리즘을 통해 구현을 하면 되는 문제로 보였습니다. 그리고 해당 알고리즘은 학교의 알고리즘 강의에서 의사코드 수준으로 배웠습니다 그렇기에 문제 접근 자체는 쉽게 했습니다.
* 간선의 cost를 오름차순으로 정렬하는 것까지는 앞선 주차에서 정렬을 공부했었기에 성공했으나 어떤 정점 사이의 간선이 이미 최단거리라고 정렬한 집합 안에 추가할지 말지 정하는 것을 구현하는데 실패했습니다.
* kruskal을 구현하려면 union_find라는 것을 구현해야 하는데 해당 부분의 구현을 배운 적이 없이 구현하려해서 실패했던 것 같습니다.
* merge sort 구현으로 간선 cost의 정렬은 해결했습니다. 
* 다음엔 문제를 풀기 위한 기본 개념을 확실히 하고 도전해야할 필요성을 느꼈습니다.

## 4주차 - c언어 풀이
2026-02-10 시행

### 14502번 graph 문제

* 해당 문제는 2차원 배열 안에서 바이러스, 즉 2라는 숫자가 있으면 그것이 확산하게 되고, 벽이 있으면 가로막혀 확산을 하지 못할 때 안전 지역의 칸 갯수를 구하는 문제였습니다.    
어떻게 벽을 설치해야 안전 지역을 최대로 할 수 있는가가 중요했습니다.
* 바이러스의 확산, 벽의 설치를 어떻게 구현할 것인지가 중요했습니다.
* 둘 모두 함수를 각각 구현하고 재귀적으로 자신을 호출하여 구현했습니다.    
바이러스의 확산의 경우엔 바이러스 주변 칸에 대해 2차원 배열의 범위 안에 있는지 그리고 확산 가능한 0인지를 체크한 후 바이러스 칸으로 변형시키고 재귀 호출을 합니다.     
벽의 설치는 이중 반복문 안에서 설치 가능한 0인 경우에 1을 설치하고 재귀적으로 호출한 후, 벽 3개를 설치하면 안전지대 칸의 갯수를 검사하고, 검사가 끝나면 벽을 해체시키고 다른 칸에 설치하고 다시 칸의 갯수를 검사하는 방식으로 구현했습니다.
* 직접적인 구현 이전에 구현에 대한 토의와 DFS의 개념을 먼저 공부하고 난 후 구현을 하니 어려운 문제였지만 생각보다 빠른 시간에 풀 수 있었습니다.
* 기초의 중요성에 대해 다시금 깨닫게 되는 시간이었습니다.

## 5주차 - c언어 풀이
2026-02-20 시행

* C언어로 PS 문제들을 구현하는 것은 다른 언어와 달리 난이도가 있었습니다. 파이썬으로 한 친구의 경우엔 편리하게 사용할 수 있도록 지원하는 함수가 더 많고 문법도 짧게 사용할 수 있어서 더 편하게 풀고 구현할 수 있었습니다. 하지만 C언어로 구현하는 것은 문법이 복잡하여 파이썬과 같은 언어와 비교해 시간이 오래걸리고 난이도가 높았습니다. 하지만 완성했을 경우 실행 속도는 C언어가 월등히 빨랐습니다.
* 그런 경험들을 하면서 다음과 같은 결론을 냈습니다. PS를 처음 입문하고 프로그래밍 언어에 대한 이해도가 C나 파이썬이나 비슷하다면 코딩 테스트를 준비할 때는 파이썬과 같은 언어들이 더 유리합니다. 하지만 임베디드 개발을 하거나 프로그래밍 언어를 처음 공부하는 시기에는 C언어를 공부하는 것이 좋다고 생각했습니다.
* 파이썬의 경우엔 다양한 함수를 지원하기 때문에 어떤 프로그램을 완성하면 메모리를 굉장히 많이 차지합니다. 또한 C언어와 파이썬의 컴파일, 인터프리터 방식의 차이로 인해 C언어가 더 빠르기 때문에 임베디드 개발에 적합합니다.
* 그리고 C언어는 파이썬보다 컴퓨터 친화적, 즉 메모리와 CPU를 직접적으로 사용합니다. 메모리 할당 및 해제, 포인터의 사용 등 컴퓨터의 사고방식을 이해하는데 C언어가 더 좋기 때문에 프로그래밍 언어를 처음 접하는 사람이라면 C언어를 배우는 것이 좋습니다. 
* 그렇기 때문에 상황에 맞는 언어를 잘 선택하는 것이 개발자가 갖춰야 할 역량이라 결론지었습니다.
* 코드리뷰를 하면서는 어떤 코드를 어떻게 하면 더 효율적으로 작성할 수 있는지에 대해 의견을 나눴습니다.
* 예를 들어 어떤 문제 상황이 BFS와 DFS라는 두 알고리즘 중 어떤 알고리즘으로도 풀 수 있다고 합니다. 그럴 때 구체적인 상황에 따라 깊이 탐색을 먼저 하는 것이 좋다면 DFS를, 같은 레벨을 먼저 하는 것이 좋다면 BFS를 사용하는 것이 좋습니다. 속도 측면에서 깊은 곳에 있는 것을 찾아야 하는데 BFS를 사용한다면 DFS보다 느릴 것이며 메모리 역시 더 많이 차지할 것입니다. 같은 레벨의 다른 요소를 찾아야 하는데 DFS를 사용한다면 BFS보다 속도가 느리고 메모리 낭비가 생길 것입니다.
* 이처럼 기초적인 알고리즘은 이해와 암기를 하여 상황에 잘 적용할 수 있도록 공부하는 것이 AI시대에도 중요하다고 생각했습니다.
* AI의 발전으로 빠르게 정보를 찾고, 간단한 혹은 복잡한 일에 AI를 활용해 높은 효율을 낼 수 있습니다. 이것은 기초를 몰라도 된다는 것이 아니라 기초를 알 수록 더 활용을 잘 할 수 있다는 것을 의미합니다. 더 좋은 질문을 던질 수 있고, 생산성을 높일 수 있습니다.
* PS 공부의 필요성을 느낄 수 있는 모각소 활동이었습니다.
